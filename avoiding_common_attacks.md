# Avoiding Common Attacks

This document explains the measures I took to ensure my contracts are not susceptible to common attacks.

## Logic Bugs

The risk of logic bugs are minimized by keeping the contract structure as simple as possible. In this case the contract is basically a database of stores and products in each store with associated create, read, update, and delete methods. All functions are short, no function calls another function, and modifiers are limited to checking preconditions. This all makes it easy to understand the code and decreases the likelihood of logic bugs.

Along the same lines, following coding standards and best practices reduces the risk of logic bugs. The code for this smart contract implements several design patterns such as the withdrawal pattern for transferring ether and the checks effects interactions pattern for interacting with external contracts. The use of a standard format to document the code also improves readability and helps catch bugs.

Finally, unit testing helps to catch bugs. This contract includes 17 unit tests and I identified at least one bug through these tests. In a production environment I would probably want an even larger test suite, possibly supplements by some kind of property based testing framework, since it is difficult to anticipate every situation in which a contract might fail.

## Recursive Calls

To avoid the risk of reentrancy attacks, the `Market` contract makes very few calls to external contracts. Specifically the only external calls are to the `Math` library contract from the `purchaseProduct` function and to `transfer` from the `purchaseProduct`, `withdrawFunds`, and `removeStore` functions.

The call to the `Math` library function is secure because the library is deployed by us, it contains no external function calls itself, and its only function is pure and therefore does not modify contract state.

The calls to `transfer` are secure because the gas limit provided by `transfer` is too low for called contract's fallback function to execute another external function call and try to modify the market's state. Furthermore, all the calls to `transfer` are after all contract state has been modified, so for example the user's balance would already be reduced and the user would not be able to withdraw more than his balance through a recursive call.

## Integer Arithmetic Overflow

Integer arithmetic occurs at two places in the Market contract. First, in the `purchaseProduct` function the contract multiplies the price and quantity to get the cost of the purchase, adds the cost to the store's balance, reduces the store's inventory, and refunds any excess payment to the buyer. Second, in the `withdrawFunds` function the contract reduces the store's balance by the amount withdrawn.

While unlikely given real world values, the multiplication of the price and quantity could potentially cause integer overflow, especially if users are supplying poison data. To address this, the `Market` contract uses the `times` function from the `Math` library to do this operation. The `times` function checks for integer overflow and throws an error if that occurs, eliminating any vulnerability here.

The addition of the cost to the store's balance is also unproblematic because this occurs after a check that the amount of ether sent is greater than or equal to the cost. So a malicious user would not be able to send enough ether to trigger an overflow given that the size of `uint` in ethereum is `2^256`.

Finally, the two subtractions are secure because they occur after checks that the subtraction will not underflow: the quantity purchased must be less than the store's inventory and the amount withdrawn must be less than the store's balance.

## Poison Data

The possibility of users entering data is addressed in a couple of different ways.

First, all data other than simply changing boolean flags is provided by store owners, who have to be approved by store administrators. So the contract doesn't allow completely untrusted parties to enter data at all, other than purchasing a product and selecting a quantity to purchase, which is highly validated in that it has to be an integer less than the quantity the store owner has listed for sale.

Second and more broadly, the contract is structured to be highly scalable so users maliciously providing large amounts of data does not detract from the performance of the contract. All of the data is stored in mappings and the contract never uses iteration. The key functions are all done based on an integer identification number that is generated by the contract

## Exposed Functions

Access to functions is controlled very tightly through modifiers. There is a clear delineation in the `Market` contract between the owner, administrators, store owners, and users. Clearly labeled modifiers restrict access to each function, functions are laid out by the level of access required in the source code to allow easy auditing, and no functions call other functions so the flow of control is very clear.

## Exposed Secrets

The contract is built with an acknowledgement that all data on the blockchain is public. All of the data consists of stores and products and the expectation is that all of it is public and in fact the contract is designed to make that information extremely accessible.

## Timestamp Vulnerabilities

The contract does not rely on any uses of a timestamp that could be manipulated by miners.

## Malicious Admins

The possibility of malicious behavior by privileged participants is addressed in several ways.

One possibility is that there is a malicious administrator. In this case the potential harm is quite minimal. A malicious administrator could remove store owners from the approved store owners list, which would prevent buyers from purchasing products from those stores and prevent the store owner from managing their stores. However, even in this situation a store owner could still withdraw funds from the store and no information would be lost.

The situation could be rectified by the owner of the contract removing the malicious administrator, adding himself or another trusted party as an administrator, and approving the store owners.

Another more serious possibility is that the owner of the `Market` contract himself is malicious. However, even here the potential damage is relatively low. The only functions the contract owner can call are adding and removing administrators and closing the market. Even if the owner closed the market and activated the emergency stop, store owners would still be able to withdraw funds from their stores. At this point they could deploy another version of the market contract with a trusted owner. Obviously this would be disruptive but no funds would be at risk.

## Off Chain Safety

Given that this is project on a local development server off chain safety measures have not been implemented. In a production environment it would be important to take measures such as ensuring that keys for owner and administrator accounts were protected (e.g. two factor authentication) and providing users with a way to confirm that they were interacting with the authentic web application (e.g. HTTPS).

## Cross Chain Replay Attacks

A cross chain replay attack would likely need to be handled out of band. In the event of a hard fork, users would have to determine which was the true chain that they would take actions off the chain based on, such as shipping a purchased product. In practice, the safest approach might be for store owners to withdraw their funds in advance of the fork and then deploy a new version of the smart contract after the fork to avoid any potential issues.

## `tx.origin`

The contract uses `msg.sender` rather than `tx.origin` so this is not an issue.

## Gas Limits

The contract doesn't use any looping over arrays. All functions are simply putting a value in a mapping, getting a value from a mapping, or updating a value in a mapping with a known key so exceeding the block gas limit shouldn't be an issue.